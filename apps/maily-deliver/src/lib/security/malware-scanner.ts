import axios from 'axios'
import { exec } from 'child_process'
import { createHash } from 'crypto'
import { Redis } from 'ioredis'
import { promisify } from 'util'

import { MetricsService } from '../monitoring'
import { SecurityService } from './security'

const execAsync = promisify(exec)

interface MalwareScanConfig {
  enabled: boolean
  engines: {
    clamav?: {
      socket?: string
      binary?: string
      database?: string
      updateInterval: number
    }
    virustotal?: {
      apiKey: string
      minEngines: number
      timeout: number
    }
    yara?: {
      rulesDir: string
      updateInterval: number
    }
  }
  caching: {
    enabled: boolean
    ttl: number
  }
  maxFileSize: number
  scanTimeout: number
  quarantineDir?: string
}

interface ScanResult {
  isInfected: boolean
  threats: string[]
  engines: {
    name: string
    detected: boolean
    threat?: string
    details?: any
  }[]
  metadata: {
    fileHash: string
    fileSize: number
    mimeType: string
    scanDuration: number
  }
}

export class MalwareScanner {
  private redis: Redis
  private cache: Map<string, ScanResult> = new Map()
  private yaraRules: any[] = []
  
  constructor(
    private config: MalwareScanConfig,
    private metrics: MetricsService,
    private security: SecurityService,
    redisUrl: string
  ) {
    this.redis = new Redis(redisUrl)
    this.initializeService()
  }

  async scanFile(
    file: Buffer | string,
    options?: {
      fastScan?: boolean
      deepScan?: boolean
      priority?: number
    }
  ): Promise<ScanResult> {
    try {
      const startTime = Date.now()
      
      // Calculate file hash
      const fileHash = this.calculateHash(file)
      
      // Check cache first
      if (this.config.caching.enabled) {
        const cached = await this.getCachedResult(fileHash)
        if (cached) {
          await this.metrics.recordLatency(
            'malware_scan_cache_hit',
            Date.now() - startTime
          )
          return cached
        }
      }

      // Convert file to buffer if string path
      const fileBuffer = typeof file === 'string' 
        ? await this.readFile(file)
        : file

      // Check file size
      if (fileBuffer.length > this.config.maxFileSize) {
        throw new Error('File size exceeds maximum allowed size')
      }

      // Run all enabled scanners in parallel
      const results = await Promise.all([
        this.config.engines.clamav && this.scanWithClamAV(fileBuffer),
        this.config.engines.virustotal && this.scanWithVirusTotal(fileBuffer),
        this.config.engines.yara && this.scanWithYara(fileBuffer)
      ].filter(Boolean))

      // Combine results
      const scanResult = this.combineResults(results, fileBuffer)
      
      // Cache results
      if (this.config.caching.enabled) {
        await this.cacheResult(fileHash, scanResult)
      }

      // Handle infected files
      if (scanResult.isInfected && this.config.quarantineDir) {
        await this.quarantineFile(fileBuffer, fileHash)
      }

      await this.metrics.recordLatency(
        'malware_scan',
        Date.now() - startTime
      )
      
      return scanResult
    } catch (error) {
      await this.metrics.recordError('malware_scan', error.message)
      throw error
    }
  }

  async getScanStats(): Promise<{
    totalScans: number
    infectedFiles: number
    engineStats: Record<string, {
      scans: number
      detections: number
    }>
    commonThreats: Array<{
      name: string
      count: number
    }>
  }> {
    try {
      const stats = await this.redis.hgetall('malware_scan_stats')
      return {
        totalScans: parseInt(stats.total_scans || '0'),
        infectedFiles: parseInt(stats.infected_files || '0'),
        engineStats: JSON.parse(stats.engine_stats || '{}'),
        commonThreats: JSON.parse(stats.common_threats || '[]')
      }
    } catch (error) {
      await this.metrics.recordError('malware_scan_stats', error.message)
      throw error
    }
  }

  // Private Methods
  private async initializeService(): Promise<void> {
    try {
      // Initialize scanning engines
      if (this.config.engines.clamav) {
        await this.initializeClamAV()
      }
      if (this.config.engines.yara) {
        await this.initializeYara()
      }
      
      // Setup metrics
      this.setupMetrics()
      
      // Start update schedules
      this.startUpdateSchedules()
    } catch (error) {
      console.error('Failed to initialize malware scanner:', error)
    }
  }

  private calculateHash(file: Buffer | string): string {
    const content = Buffer.isBuffer(file) ? file : Buffer.from(file)
    return createHash('sha256').update(content).digest('hex')
  }

  private async readFile(path: string): Promise<Buffer> {
    // Implementation for reading file
    return Buffer.from('')
  }

  private async scanWithClamAV(file: Buffer): Promise<{
    engine: string
    detected: boolean
    threat?: string
    details?: any
  }> {
    try {
      const { binary, socket } = this.config.engines.clamav!
      
      if (socket) {
        // Use ClamAV daemon mode
        // Implementation for socket-based scanning
      } else if (binary) {
        // Use command-line mode
        const { stdout } = await execAsync(
          `${binary} --stdout --database=${this.config.engines.clamav!.database}`,
          {
            input: file,
            timeout: this.config.scanTimeout
          }
        )
        
        const detected = !stdout.includes('OK')
        return {
          engine: 'clamav',
          detected,
          threat: detected ? this.parseClamAVOutput(stdout) : undefined
        }
      }
      
      throw new Error('ClamAV configuration is invalid')
    } catch (error) {
      await this.metrics.recordError('clamav_scan', error.message)
      return {
        engine: 'clamav',
        detected: false,
        details: { error: error.message }
      }
    }
  }

  private async scanWithVirusTotal(file: Buffer): Promise<{
    engine: string
    detected: boolean
    threat?: string
    details?: any
  }> {
    try {
      const { apiKey, minEngines, timeout } = this.config.engines.virustotal!
      
      // Calculate file hash
      const fileHash = this.calculateHash(file)
      
      // Check if file has been scanned before
      const response = await axios.get(
        `https://www.virustotal.com/vtapi/v2/file/report`,
        {
          params: {
            apikey: apiKey,
            resource: fileHash
          },
          timeout
        }
      )

      if (response.data.response_code === 0) {
        // File hasn't been scanned, upload it
        const formData = new FormData()
        formData.append('file', file)
        formData.append('apikey', apiKey)
        
        const uploadResponse = await axios.post(
          'https://www.virustotal.com/vtapi/v2/file/scan',
          formData,
          { timeout }
        )
        
        // Wait for scan to complete
        const scanId = uploadResponse.data.scan_id
        const result = await this.pollVirusTotalResult(scanId)
        
        const detected = result.positives >= minEngines
        return {
          engine: 'virustotal',
          detected,
          threat: detected ? this.getVirusTotalThreatName(result) : undefined,
          details: result
        }
      }

      const detected = response.data.positives >= minEngines
      return {
        engine: 'virustotal',
        detected,
        threat: detected ? this.getVirusTotalThreatName(response.data) : undefined,
        details: response.data
      }
    } catch (error) {
      await this.metrics.recordError('virustotal_scan', error.message)
      return {
        engine: 'virustotal',
        detected: false,
        details: { error: error.message }
      }
    }
  }

  private async scanWithYara(file: Buffer): Promise<{
    engine: string
    detected: boolean
    threat?: string
    details?: any
  }> {
    try {
      // Scan file with loaded YARA rules
      const matches = []
      
      for (const rule of this.yaraRules) {
        if (await this.matchYaraRule(rule, file)) {
          matches.push(rule.identifier)
        }
      }

      return {
        engine: 'yara',
        detected: matches.length > 0,
        threat: matches.join(', '),
        details: { matches }
      }
    } catch (error) {
      await this.metrics.recordError('yara_scan', error.message)
      return {
        engine: 'yara',
        detected: false,
        details: { error: error.message }
      }
    }
  }

  private async initializeClamAV(): Promise<void> {
    if (this.config.engines.clamav?.binary) {
      // Test ClamAV installation
      try {
        await execAsync(`${this.config.engines.clamav.binary} --version`)
      } catch (error) {
        throw new Error(`ClamAV binary not found: ${error.message}`)
      }
    }
  }

  private async initializeYara(): Promise<void> {
    // Load YARA rules
    // Implementation for loading YARA rules
  }

  private async pollVirusTotalResult(
    scanId: string,
    maxAttempts = 10
  ): Promise<any> {
    const { apiKey, timeout } = this.config.engines.virustotal!
    
    for (let i = 0; i < maxAttempts; i++) {
      const response = await axios.get(
        'https://www.virustotal.com/vtapi/v2/file/report',
        {
          params: {
            apikey: apiKey,
            resource: scanId
          },
          timeout
        }
      )

      if (response.data.response_code === 1) {
        return response.data
      }

      // Wait before next attempt
      await new Promise(resolve => setTimeout(resolve, 15000))
    }
    
    throw new Error('VirusTotal scan timed out')
  }

  private getVirusTotalThreatName(result: any): string {
    // Get most common detection name
    const detections = Object.values(result.scans)
      .filter((scan: any) => scan.detected)
      .map((scan: any) => scan.result)
    
    return detections[0] || 'Unknown threat'
  }

  private async matchYaraRule(rule: any, file: Buffer): Promise<boolean> {
    // Implementation for matching YARA rules
    return false
  }

  private async getCachedResult(hash: string): Promise<ScanResult | null> {
    // Check memory cache first
    if (this.cache.has(hash)) {
      return this.cache.get(hash)!
    }

    // Check Redis cache
    const cached = await this.redis.get(`malware_scan:${hash}`)
    if (cached) {
      const result = JSON.parse(cached)
      this.cache.set(hash, result)
      return result
    }

    return null
  }

  private async cacheResult(
    hash: string,
    result: ScanResult
  ): Promise<void> {
    // Update memory cache
    this.cache.set(hash, result)

    // Update Redis cache
    await this.redis.setex(
      `malware_scan:${hash}`,
      this.config.caching.ttl,
      JSON.stringify(result)
    )
  }

  private async quarantineFile(
    file: Buffer,
    hash: string
  ): Promise<void> {
    // Implementation for quarantining infected files
  }

  private combineResults(
    results: Array<{
      engine: string
      detected: boolean
      threat?: string
      details?: any
    }>,
    file: Buffer
  ): ScanResult {
    const threats = results
      .filter(r => r.detected && r.threat)
      .map(r => r.threat!)
    
    return {
      isInfected: results.some(r => r.detected),
      threats: [...new Set(threats)],
      engines: results,
      metadata: {
        fileHash: this.calculateHash(file),
        fileSize: file.length,
        mimeType: this.detectMimeType(file),
        scanDuration: 0 // Set by caller
      }
    }
  }

  private detectMimeType(file: Buffer): string {
    // Implementation for MIME type detection
    return 'application/octet-stream'
  }

  private startUpdateSchedules(): void {
    // Schedule ClamAV updates
    if (this.config.engines.clamav) {
      setInterval(async () => {
        try {
          await this.updateClamAV()
        } catch (error) {
          console.error('ClamAV update failed:', error)
        }
      }, this.config.engines.clamav.updateInterval * 60 * 1000)
    }

    // Schedule YARA rules updates
    if (this.config.engines.yara) {
      setInterval(async () => {
        try {
          await this.updateYaraRules()
        } catch (error) {
          console.error('YARA rules update failed:', error)
        }
      }, this.config.engines.yara.updateInterval * 60 * 1000)
    }
  }

  private async updateClamAV(): Promise<void> {
    // Implementation for updating ClamAV
  }

  private async updateYaraRules(): Promise<void> {
    // Implementation for updating YARA rules
  }

  private parseClamAVOutput(output: string): string {
    // Implementation for parsing ClamAV output
    return 'Unknown threat'
  }

  private setupMetrics(): void {
    this.metrics.registerCounter(
      'malware_scans_total',
      'Total number of malware scans'
    )
    this.metrics.registerCounter(
      'malware_detections',
      'Number of malware detections'
    )
    this.metrics.registerHistogram(
      'malware_scan_latency',
      'Malware scan latency in seconds',
      [0.1, 0.5, 1, 2, 5, 10]
    )
    this.metrics.registerGauge(
      'malware_scan_cache_size',
      'Current size of malware scan cache'
    )
  }
} 