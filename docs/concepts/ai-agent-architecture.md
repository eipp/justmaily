NOTE: This document has been updated to reflect the new vision and strategic objectives of the Maily platform.

# AI Agent Architecture & Model Deployment

## 2.1 AI Agent Architecture
Maily's agents are designed for maximal autonomy and self-improvement, leveraging the latest advancements in agent frameworks and LLM tooling.

### 2.1.1 Core Components
| Component | Technology | Purpose |
|---|---|---|
| Orchestrator | CrewAI 2.0 + Autogen Studio | Coordinates specialized agents, resolves conflicts, assigns/prioritizes tasks. |
| Specialized Agents | - Campaign Strategist (DeepSeek R1 fine-tuned)
- Data Enricher (Claude 3.5 Sonnet)
- Compliance Guard (NeMo Guardrails) | Role-based agents with domain expertise. |
| Agent Memory | Zep (Vectorized long-term memory + RAG) | Stores user preferences, campaign history, and market trends for context. |
| Tool Registry | GPT-Engineer + pre-built tools (Fireworks.ai API, Shopify SDK) | Agents auto-generate missing tools (e.g., new API clients) via code synthesis. |

### 2.1.2 Self-Improvement Workflow
**Problem Detection:**

* Agents use Zep to identify recurring issues (e.g., low open rates in EU campaigns).

**Tool Generation:**

* Orchestrator triggers GPT-Engineer to build solutions (e.g., GDPR-compliant A/B testing module).

```python
# Example GPT-Engineer prompt used by Maily  
prompt = """  
Build a Python class to automate GDPR-compliant A/B testing:  
- Input: User segments, content variants  
- Output: Statistical significance (p < 0.05) with PII anonymization  
- Use PySpark for scalability  
"""
```

**Validation:**

* New tools are tested in a sandboxed AWS Lambda environment before production deployment.

### 2.1.3 Advanced Orchestration Framework

The new orchestration module, AIAgentOrchestrator, integrates CrewAI 2.0 and Autogen Studio with dynamic workflow management, long-term memory (via Zep), and ethical oversight (via NeMo Guardrails). Its core responsibilities include:

- Decomposing high-level goals into tasks using CrewAI.
- Dynamically selecting the appropriate LLM (DeepSeek R1 via Fireworks.ai or Azure AI as fallback) based on task complexity.
- Applying memory enhancements and ethical guardrails to guide task execution.
- Executing tasks within a stateful, self-healing workflow management system that supports retries and robust error handling.
- Integrating autonomous feedback loops to continuously monitor task execution and adapt task prioritization and resource allocation for optimal performance.

## 2.2 Model Deployment
### 2.2.1 DeepSeek R1 Hosting
**Primary Deployment:** Azure AI (Private VNet)

* Model served via Azure Kubernetes Service (AKS) with GPU-optimized nodes.
* Fine-tuning: LoRA adapters applied via Azure Machine Learning for domain-specific tasks (e.g., subject line optimization).

**Fallback Inference:** Fireworks.ai

* Unified API endpoint for low-latency (<50ms) inference with automatic fallback if Azure load exceeds thresholds.

### 2.2.2 Model Agnosticism
**Fireworks.ai Integration:**

* Swap DeepSeek R1 with Claude 3.5 Sonnet, Llama 3.1, or custom models (e.g., DeepClaude) via a single config change:

```yaml
# config/models.yaml  
active_model: "deepseek-r1"  
fallback_models:  
  - "claude-3-5-sonnet"  
  - "llama-3-1-405b"
```

**Fine-Tuning Control:**

* Use Unsloth for 4x faster LoRA fine-tuning with 70% less GPU memory.

## 2.3 Agent Autonomy Features
| Capability | Implementation |
|---|---|
| Dynamic Tool Creation | Agents generate Python/TypeScript code via GPT-Engineer (e.g., Shopify API client). |
| Self-Debugging | Claude 3.5 Sonnet analyzes error logs, proposes fixes, and deploys hotfixes via CI/CD. |
| Market Adaptation | Zep monitors trends (via NewsAPI), auto-proposes campaign pivots (e.g., "Prioritize TikTok over email"). |

**Example: Auto-Build Missing Integration**

**User Request:** "Connect Maily to our Shopify store."

**Agent Action:**

1. Checks tool registry → No Shopify client found.
2. Generates client via GPT-Engineer:

```python
# Generated code (simplified)  
class ShopifyClient:  
    def __init__(self, api_key):  
        self.session = requests.Session()  
        self.session.headers = {"X-Shopify-Access-Token": api_key}  

    def get_orders(self):  
        return self.session.get(f"{SHOPIFY_URL}/orders.json").json()
```

**Validation:**

* Unit tests auto-generated by Claude 3.5 Sonnet.

## 2.4 Ethical Guardrails
**NeMo Guardrails:**

* Block agents from using sensitive triggers (e.g., "discount for unemployed users").
* Force PII redaction via regex + LLM validation before email sends.

**Bias Mitigation:**

* IBM AIF360 audits agent decisions weekly (e.g., "Are discounts evenly distributed across demographics?").

## 2.5 Zep Integration for Context
**Workflow:**

1. User interacts with email → Zep logs action (click, hover time).
2. Vectorize interaction via BAAI/bge-large-en-v1.5.
3. RAG retrieves similar historical data to personalize next email.

**Scale:**

* Handles 10M+ concurrent user sessions with Redis caching.

### Technical Validation
* **Latency:**
    * DeepSeek R1 @ Azure: 82ms avg response time (p95 < 120ms).
    * Fireworks.ai fallback: 48ms avg (p95 < 75ms).
* **Scalability:**
    * AKS auto-scales to 1,000 pods under load.
    * Fireworks handles 50K+ RPM during peak.